{"version":3,"file":"vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js.js","mappings":";;;;;;;;;;;;;;AAAyI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA,8CAA8C,+CAAC;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA,8BAA8B,OAAO;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,sBAAsB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,gBAAgB,IAAI;AAC9C;AACA;AACA,sBAAsB,2CAAC,wBAAwB,2CAAC,0BAA0B,2CAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2QAA2Q,OAAO;AAClR;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,+CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,+CAAC,CAAC,+CAAC,YAAY,eAAe,+CAAC,WAAW,2CAAC;AAC/E;AACA,aAAa,+CAAC;AACd,cAAc,+CAAC;AACf;AACA,uBAAuB,+CAAC;AACxB,mBAAmB,+CAAC;AACpB,oBAAoB,+CAAC;AACrB,mBAAmB,+CAAC;AACpB,aAAa,+CAAC;AACd,YAAY,+CAAC;AACb;AACA;AACA;AACA;AACA,cAAc,+CAAC;AACf,eAAe,+CAAC;AAChB;AACA,eAAe,+CAAC,CAAC,+CAAC;AAClB;AACA,gBAAgB,+CAAC;AACjB;AACA,iBAAiB,+CAAC;AAClB,sBAAsB,+CAAC;AACvB,uBAAuB,+CAAC;AACxB,uBAAuB,+CAAC;AACxB,uBAAuB,+CAAC;AACxB;AACA,GAAG;AACH;AACA,gFAAgF,+CAAC;AACjF,qCAAqC,+CAAC,CAAC,+CAAC,+BAA+B,+CAAC;AACxE,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B,UAAU,sBAAsB;AAChC,UAAU,4BAA4B;AACtC,UAAU,sBAAsB;AAChC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,mEAAmE,uCAAuC;AAC1G;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA,CAAC;AACD,MAAM,+CAAC;AACP;AACA;AACA,MAAM,+CAAE;AACR,SAAS,+CAAC;AACV;AACA,cAAc,+CAAC;AACf;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8BAA8B;AAC9B,+CAA+C,OAAO,+CAAC,GAAG,6BAA6B;AACvF,mBAAmB,+CAAC,GAAG;AACvB;AACA;AACA,QAAQ;AACR;AACA,GAAG;AACH,WAAW,+CAAC,kBAAkB;AAC9B,uBAAuB;AACvB,KAAK;AACL,GAAG,IAAI;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8CAA8C,+CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC;AACvC,GAAG;AACH;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,iBAAiB,+CAAC;AAClB;AACA,yBAAyB;AACzB;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,OAAO;AACrC;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AAGE;AACF","sources":["webpack://wptailpack/./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"],"sourcesContent":["import { m as g, i as p, t as q, r as f, d as J, a as K, v as V, c as z, e as Y, A as Q, P as Z, B as ee, b as re } from \"./chart.es.js\";\n/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */\nvar D = function() {\n  if (typeof window < \"u\") {\n    if (window.devicePixelRatio)\n      return window.devicePixelRatio;\n    var e = window.screen;\n    if (e)\n      return (e.deviceXDPI || 1) / (e.logicalXDPI || 1);\n  }\n  return 1;\n}(), m = {\n  // @todo move this in Chart.helpers.toTextLines\n  toTextLines: function(e) {\n    var t = [], r;\n    for (e = [].concat(e); e.length; )\n      r = e.pop(), typeof r == \"string\" ? t.unshift.apply(t, r.split(`\n`)) : Array.isArray(r) ? e.push.apply(e, r) : p(e) || t.unshift(\"\" + r);\n    return t;\n  },\n  // @todo move this in Chart.helpers.canvas.textSize\n  // @todo cache calls of measureText if font doesn't change?!\n  textSize: function(e, t, r) {\n    var a = [].concat(t), i = a.length, n = e.font, o = 0, s;\n    for (e.font = r.string, s = 0; s < i; ++s)\n      o = Math.max(e.measureText(a[s]).width, o);\n    return e.font = n, {\n      height: i * r.lineHeight,\n      width: o\n    };\n  },\n  /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */\n  bound: function(e, t, r) {\n    return Math.max(e, Math.min(t, r));\n  },\n  /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */\n  arrayDiff: function(e, t) {\n    var r = e.slice(), a = [], i, n, o, s;\n    for (i = 0, o = t.length; i < o; ++i)\n      s = t[i], n = r.indexOf(s), n === -1 ? a.push([s, 1]) : r.splice(n, 1);\n    for (i = 0, o = r.length; i < o; ++i)\n      a.push([r[i], -1]);\n    return a;\n  },\n  /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */\n  rasterize: function(e) {\n    return Math.round(e * D) / D;\n  }\n};\nfunction A(e, t) {\n  var r = t.x, a = t.y;\n  if (r === null)\n    return { x: 0, y: -1 };\n  if (a === null)\n    return { x: 1, y: 0 };\n  var i = e.x - r, n = e.y - a, o = Math.sqrt(i * i + n * n);\n  return {\n    x: o ? i / o : 0,\n    y: o ? n / o : -1\n  };\n}\nfunction ae(e, t, r, a, i) {\n  switch (i) {\n    case \"center\":\n      r = a = 0;\n      break;\n    case \"bottom\":\n      r = 0, a = 1;\n      break;\n    case \"right\":\n      r = 1, a = 0;\n      break;\n    case \"left\":\n      r = -1, a = 0;\n      break;\n    case \"top\":\n      r = 0, a = -1;\n      break;\n    case \"start\":\n      r = -r, a = -a;\n      break;\n    case \"end\":\n      break;\n    default:\n      i *= Math.PI / 180, r = Math.cos(i), a = Math.sin(i);\n      break;\n  }\n  return {\n    x: e,\n    y: t,\n    vx: r,\n    vy: a\n  };\n}\nvar te = 0, j = 1, N = 2, O = 4, F = 8;\nfunction M(e, t, r) {\n  var a = te;\n  return e < r.left ? a |= j : e > r.right && (a |= N), t < r.top ? a |= F : t > r.bottom && (a |= O), a;\n}\nfunction ie(e, t) {\n  for (var r = e.x0, a = e.y0, i = e.x1, n = e.y1, o = M(r, a, t), s = M(i, n, t), l, u, v; !(!(o | s) || o & s); )\n    l = o || s, l & F ? (u = r + (i - r) * (t.top - a) / (n - a), v = t.top) : l & O ? (u = r + (i - r) * (t.bottom - a) / (n - a), v = t.bottom) : l & N ? (v = a + (n - a) * (t.right - r) / (i - r), u = t.right) : l & j && (v = a + (n - a) * (t.left - r) / (i - r), u = t.left), l === o ? (r = u, a = v, o = M(r, a, t)) : (i = u, n = v, s = M(i, n, t));\n  return {\n    x0: r,\n    x1: i,\n    y0: a,\n    y1: n\n  };\n}\nfunction P(e, t) {\n  var r = t.anchor, a = e, i, n;\n  return t.clamp && (a = ie(a, t.area)), r === \"start\" ? (i = a.x0, n = a.y0) : r === \"end\" ? (i = a.x1, n = a.y1) : (i = (a.x0 + a.x1) / 2, n = (a.y0 + a.y1) / 2), ae(i, n, e.vx, e.vy, t.align);\n}\nvar E = {\n  arc: function(e, t) {\n    var r = (e.startAngle + e.endAngle) / 2, a = Math.cos(r), i = Math.sin(r), n = e.innerRadius, o = e.outerRadius;\n    return P({\n      x0: e.x + a * n,\n      y0: e.y + i * n,\n      x1: e.x + a * o,\n      y1: e.y + i * o,\n      vx: a,\n      vy: i\n    }, t);\n  },\n  point: function(e, t) {\n    var r = A(e, t.origin), a = r.x * e.options.radius, i = r.y * e.options.radius;\n    return P({\n      x0: e.x - a,\n      y0: e.y - i,\n      x1: e.x + a,\n      y1: e.y + i,\n      vx: r.x,\n      vy: r.y\n    }, t);\n  },\n  bar: function(e, t) {\n    var r = A(e, t.origin), a = e.x, i = e.y, n = 0, o = 0;\n    return e.horizontal ? (a = Math.min(e.x, e.base), n = Math.abs(e.base - e.x)) : (i = Math.min(e.y, e.base), o = Math.abs(e.base - e.y)), P({\n      x0: a,\n      y0: i + o,\n      x1: a + n,\n      y1: i,\n      vx: r.x,\n      vy: r.y\n    }, t);\n  },\n  fallback: function(e, t) {\n    var r = A(e, t.origin);\n    return P({\n      x0: e.x,\n      y0: e.y,\n      x1: e.x + (e.width || 0),\n      y1: e.y + (e.height || 0),\n      vx: r.x,\n      vy: r.y\n    }, t);\n  }\n}, x = m.rasterize;\nfunction ne(e) {\n  var t = e.borderWidth || 0, r = e.padding, a = e.size.height, i = e.size.width, n = -i / 2, o = -a / 2;\n  return {\n    frame: {\n      x: n - r.left - t,\n      y: o - r.top - t,\n      w: i + r.width + t * 2,\n      h: a + r.height + t * 2\n    },\n    text: {\n      x: n,\n      y: o,\n      w: i,\n      h: a\n    }\n  };\n}\nfunction oe(e, t) {\n  var r = t.chart.getDatasetMeta(t.datasetIndex).vScale;\n  if (!r)\n    return null;\n  if (r.xCenter !== void 0 && r.yCenter !== void 0)\n    return { x: r.xCenter, y: r.yCenter };\n  var a = r.getBasePixel();\n  return e.horizontal ? { x: a, y: null } : { x: null, y: a };\n}\nfunction se(e) {\n  return e instanceof Q ? E.arc : e instanceof Z ? E.point : e instanceof ee ? E.bar : E.fallback;\n}\nfunction le(e, t, r, a, i, n) {\n  var o = Math.PI / 2;\n  if (n) {\n    var s = Math.min(n, i / 2, a / 2), l = t + s, u = r + s, v = t + a - s, d = r + i - s;\n    e.moveTo(t, u), l < v && u < d ? (e.arc(l, u, s, -Math.PI, -o), e.arc(v, u, s, -o, 0), e.arc(v, d, s, 0, o), e.arc(l, d, s, o, Math.PI)) : l < v ? (e.moveTo(l, r), e.arc(v, u, s, -o, o), e.arc(l, u, s, o, Math.PI + o)) : u < d ? (e.arc(l, u, s, -Math.PI, 0), e.arc(l, d, s, 0, Math.PI)) : e.arc(l, u, s, -Math.PI, Math.PI), e.closePath(), e.moveTo(t, r);\n  } else\n    e.rect(t, r, a, i);\n}\nfunction ue(e, t, r) {\n  var a = r.backgroundColor, i = r.borderColor, n = r.borderWidth;\n  !a && (!i || !n) || (e.beginPath(), le(\n    e,\n    x(t.x) + n / 2,\n    x(t.y) + n / 2,\n    x(t.w) - n,\n    x(t.h) - n,\n    r.borderRadius\n  ), e.closePath(), a && (e.fillStyle = a, e.fill()), i && n && (e.strokeStyle = i, e.lineWidth = n, e.lineJoin = \"miter\", e.stroke()));\n}\nfunction ve(e, t, r) {\n  var a = r.lineHeight, i = e.w, n = e.x, o = e.y + a / 2;\n  return t === \"center\" ? n += i / 2 : (t === \"end\" || t === \"right\") && (n += i), {\n    h: a,\n    w: i,\n    x: n,\n    y: o\n  };\n}\nfunction de(e, t, r) {\n  var a = e.shadowBlur, i = r.stroked, n = x(r.x), o = x(r.y), s = x(r.w);\n  i && e.strokeText(t, n, o, s), r.filled && (a && i && (e.shadowBlur = 0), e.fillText(t, n, o, s), a && i && (e.shadowBlur = a));\n}\nfunction fe(e, t, r, a) {\n  var i = a.textAlign, n = a.color, o = !!n, s = a.font, l = t.length, u = a.textStrokeColor, v = a.textStrokeWidth, d = u && v, y;\n  if (!(!l || !o && !d))\n    for (r = ve(r, i, s), e.font = s.string, e.textAlign = i, e.textBaseline = \"middle\", e.shadowBlur = a.textShadowBlur, e.shadowColor = a.textShadowColor, o && (e.fillStyle = n), d && (e.lineJoin = \"round\", e.lineWidth = v, e.strokeStyle = u), y = 0, l = t.length; y < l; ++y)\n      de(e, t[y], {\n        stroked: d,\n        filled: o,\n        w: r.w,\n        x: r.x,\n        y: r.y + r.h * y\n      });\n}\nvar L = function(e, t, r, a) {\n  var i = this;\n  i._config = e, i._index = a, i._model = null, i._rects = null, i._ctx = t, i._el = r;\n};\ng(L.prototype, {\n  /**\n   * @private\n   */\n  _modelize: function(e, t, r, a) {\n    var i = this, n = i._index, o = q(f([r.font, {}], a, n)), s = f([r.color, J.color], a, n);\n    return {\n      align: f([r.align, \"center\"], a, n),\n      anchor: f([r.anchor, \"center\"], a, n),\n      area: a.chart.chartArea,\n      backgroundColor: f([r.backgroundColor, null], a, n),\n      borderColor: f([r.borderColor, null], a, n),\n      borderRadius: f([r.borderRadius, 0], a, n),\n      borderWidth: f([r.borderWidth, 0], a, n),\n      clamp: f([r.clamp, !1], a, n),\n      clip: f([r.clip, !1], a, n),\n      color: s,\n      display: e,\n      font: o,\n      lines: t,\n      offset: f([r.offset, 4], a, n),\n      opacity: f([r.opacity, 1], a, n),\n      origin: oe(i._el, a),\n      padding: K(f([r.padding, 4], a, n)),\n      positioner: se(i._el),\n      rotation: f([r.rotation, 0], a, n) * (Math.PI / 180),\n      size: m.textSize(i._ctx, t, o),\n      textAlign: f([r.textAlign, \"start\"], a, n),\n      textShadowBlur: f([r.textShadowBlur, 0], a, n),\n      textShadowColor: f([r.textShadowColor, s], a, n),\n      textStrokeColor: f([r.textStrokeColor, s], a, n),\n      textStrokeWidth: f([r.textStrokeWidth, 0], a, n)\n    };\n  },\n  update: function(e) {\n    var t = this, r = null, a = null, i = t._index, n = t._config, o, s, l, u = f([n.display, !0], e, i);\n    u && (o = e.dataset.data[i], s = V(z(n.formatter, [o, e]), o), l = p(s) ? [] : m.toTextLines(s), l.length && (r = t._modelize(u, l, n, e), a = ne(r))), t._model = r, t._rects = a;\n  },\n  geometry: function() {\n    return this._rects ? this._rects.frame : {};\n  },\n  rotation: function() {\n    return this._model ? this._model.rotation : 0;\n  },\n  visible: function() {\n    return this._model && this._model.opacity;\n  },\n  model: function() {\n    return this._model;\n  },\n  draw: function(e, t) {\n    var r = this, a = e.ctx, i = r._model, n = r._rects, o;\n    this.visible() && (a.save(), i.clip && (o = i.area, a.beginPath(), a.rect(\n      o.left,\n      o.top,\n      o.right - o.left,\n      o.bottom - o.top\n    ), a.clip()), a.globalAlpha = m.bound(0, i.opacity, 1), a.translate(x(t.x), x(t.y)), a.rotate(i.rotation), ue(a, n.frame, i), fe(a, i.lines, n.text, i), a.restore());\n  }\n});\nvar he = Number.MIN_SAFE_INTEGER || -9007199254740991, ye = Number.MAX_SAFE_INTEGER || 9007199254740991;\nfunction b(e, t, r) {\n  var a = Math.cos(r), i = Math.sin(r), n = t.x, o = t.y;\n  return {\n    x: n + a * (e.x - n) - i * (e.y - o),\n    y: o + i * (e.x - n) + a * (e.y - o)\n  };\n}\nfunction W(e, t) {\n  var r = ye, a = he, i = t.origin, n, o, s, l, u;\n  for (n = 0; n < e.length; ++n)\n    o = e[n], s = o.x - i.x, l = o.y - i.y, u = t.vx * s + t.vy * l, r = Math.min(r, u), a = Math.max(a, u);\n  return {\n    min: r,\n    max: a\n  };\n}\nfunction I(e, t) {\n  var r = t.x - e.x, a = t.y - e.y, i = Math.sqrt(r * r + a * a);\n  return {\n    vx: (t.x - e.x) / i,\n    vy: (t.y - e.y) / i,\n    origin: e,\n    ln: i\n  };\n}\nvar G = function() {\n  this._rotation = 0, this._rect = {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  };\n};\ng(G.prototype, {\n  center: function() {\n    var e = this._rect;\n    return {\n      x: e.x + e.w / 2,\n      y: e.y + e.h / 2\n    };\n  },\n  update: function(e, t, r) {\n    this._rotation = r, this._rect = {\n      x: t.x + e.x,\n      y: t.y + e.y,\n      w: t.w,\n      h: t.h\n    };\n  },\n  contains: function(e) {\n    var t = this, r = 1, a = t._rect;\n    return e = b(e, t.center(), -t._rotation), !(e.x < a.x - r || e.y < a.y - r || e.x > a.x + a.w + r * 2 || e.y > a.y + a.h + r * 2);\n  },\n  // Separating Axis Theorem\n  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n  intersects: function(e) {\n    var t = this._points(), r = e._points(), a = [\n      I(t[0], t[1]),\n      I(t[0], t[3])\n    ], i, n, o;\n    for (this._rotation !== e._rotation && a.push(\n      I(r[0], r[1]),\n      I(r[0], r[3])\n    ), i = 0; i < a.length; ++i)\n      if (n = W(t, a[i]), o = W(r, a[i]), n.max < o.min || o.max < n.min)\n        return !1;\n    return !0;\n  },\n  /**\n   * @private\n   */\n  _points: function() {\n    var e = this, t = e._rect, r = e._rotation, a = e.center();\n    return [\n      b({ x: t.x, y: t.y }, a, r),\n      b({ x: t.x + t.w, y: t.y }, a, r),\n      b({ x: t.x + t.w, y: t.y + t.h }, a, r),\n      b({ x: t.x, y: t.y + t.h }, a, r)\n    ];\n  }\n});\nfunction H(e, t, r) {\n  var a = t.positioner(e, t), i = a.vx, n = a.vy;\n  if (!i && !n)\n    return { x: a.x, y: a.y };\n  var o = r.w, s = r.h, l = t.rotation, u = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)), v = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(i), Math.abs(n));\n  return u *= i * d, v *= n * d, u += t.offset * i, v += t.offset * n, {\n    x: a.x + u,\n    y: a.y + v\n  };\n}\nfunction xe(e, t) {\n  var r, a, i, n;\n  for (r = e.length - 1; r >= 0; --r)\n    for (i = e[r].$layout, a = r - 1; a >= 0 && i._visible; --a)\n      n = e[a].$layout, n._visible && i._box.intersects(n._box) && t(i, n);\n  return e;\n}\nfunction _e(e) {\n  var t, r, a, i, n, o, s;\n  for (t = 0, r = e.length; t < r; ++t)\n    a = e[t], i = a.$layout, i._visible && (s = new Proxy(a._el, { get: (l, u) => l.getProps([u], !0)[u] }), n = a.geometry(), o = H(s, a.model(), n), i._box.update(o, n, a.rotation()));\n  return xe(e, function(l, u) {\n    var v = l._hidable, d = u._hidable;\n    v && d || d ? u._visible = !1 : v && (l._visible = !1);\n  });\n}\nvar w = {\n  prepare: function(e) {\n    var t = [], r, a, i, n, o;\n    for (r = 0, i = e.length; r < i; ++r)\n      for (a = 0, n = e[r].length; a < n; ++a)\n        o = e[r][a], t.push(o), o.$layout = {\n          _box: new G(),\n          _hidable: !1,\n          _visible: !0,\n          _set: r,\n          _idx: o._index\n        };\n    return t.sort(function(s, l) {\n      var u = s.$layout, v = l.$layout;\n      return u._idx === v._idx ? v._set - u._set : v._idx - u._idx;\n    }), this.update(t), t;\n  },\n  update: function(e) {\n    var t = !1, r, a, i, n, o;\n    for (r = 0, a = e.length; r < a; ++r)\n      i = e[r], n = i.model(), o = i.$layout, o._hidable = n && n.display === \"auto\", o._visible = i.visible(), t |= o._hidable;\n    t && _e(e);\n  },\n  lookup: function(e, t) {\n    var r, a;\n    for (r = e.length - 1; r >= 0; --r)\n      if (a = e[r].$layout, a && a._visible && a._box.contains(t))\n        return e[r];\n    return null;\n  },\n  draw: function(e, t) {\n    var r, a, i, n, o, s;\n    for (r = 0, a = t.length; r < a; ++r)\n      i = t[r], n = i.$layout, n._visible && (o = i.geometry(), s = H(i._el, i.model(), o), n._box.update(s, o, i.rotation()), i.draw(e, s));\n  }\n}, ce = function(e) {\n  if (p(e))\n    return null;\n  var t = e, r, a, i;\n  if (re(e))\n    if (!p(e.label))\n      t = e.label;\n    else if (!p(e.r))\n      t = e.r;\n    else\n      for (t = \"\", r = Object.keys(e), i = 0, a = r.length; i < a; ++i)\n        t += (i !== 0 ? \", \" : \"\") + r[i] + \": \" + e[r[i]];\n  return \"\" + t;\n}, be = {\n  align: \"center\",\n  anchor: \"center\",\n  backgroundColor: null,\n  borderColor: null,\n  borderRadius: 0,\n  borderWidth: 0,\n  clamp: !1,\n  clip: !1,\n  color: void 0,\n  display: !0,\n  font: {\n    family: void 0,\n    lineHeight: 1.2,\n    size: void 0,\n    style: void 0,\n    weight: null\n  },\n  formatter: ce,\n  labels: void 0,\n  listeners: {},\n  offset: 4,\n  opacity: 1,\n  padding: {\n    top: 4,\n    right: 4,\n    bottom: 4,\n    left: 4\n  },\n  rotation: 0,\n  textAlign: \"start\",\n  textStrokeColor: void 0,\n  textStrokeWidth: 0,\n  textShadowBlur: 0,\n  textShadowColor: void 0\n}, h = \"$datalabels\", U = \"$default\";\nfunction pe(e, t) {\n  var r = e.datalabels, a = {}, i = [], n, o;\n  return r === !1 ? null : (r === !0 && (r = {}), t = g({}, [t, r]), n = t.labels || {}, o = Object.keys(n), delete t.labels, o.length ? o.forEach(function(s) {\n    n[s] && i.push(g({}, [\n      t,\n      n[s],\n      { _key: s }\n    ]));\n  }) : i.push(t), a = i.reduce(function(s, l) {\n    return Y(l.listeners || {}, function(u, v) {\n      s[v] = s[v] || {}, s[v][l._key || U] = u;\n    }), delete l.listeners, s;\n  }, {}), {\n    labels: i,\n    listeners: a\n  });\n}\nfunction R(e, t, r, a) {\n  if (t) {\n    var i = r.$context, n = r.$groups, o;\n    t[n._set] && (o = t[n._set][n._key], o && z(o, [i, a]) === !0 && (e[h]._dirty = !0, r.update(i)));\n  }\n}\nfunction me(e, t, r, a, i) {\n  var n, o;\n  !r && !a || (r ? a ? r !== a && (o = n = !0) : o = !0 : n = !0, o && R(e, t.leave, r, i), n && R(e, t.enter, a, i));\n}\nfunction we(e, t) {\n  var r = e[h], a = r._listeners, i, n;\n  if (!(!a.enter && !a.leave)) {\n    if (t.type === \"mousemove\")\n      n = w.lookup(r._labels, t);\n    else if (t.type !== \"mouseout\")\n      return;\n    i = r._hovered, r._hovered = n, me(e, a, i, n, t);\n  }\n}\nfunction ge(e, t) {\n  var r = e[h], a = r._listeners.click, i = a && w.lookup(r._labels, t);\n  i && R(e, a, i, t);\n}\nvar Me = {\n  id: \"datalabels\",\n  defaults: be,\n  beforeInit: function(e) {\n    e[h] = {\n      _actives: []\n    };\n  },\n  beforeUpdate: function(e) {\n    var t = e[h];\n    t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];\n  },\n  afterDatasetUpdate: function(e, t, r) {\n    var a = t.index, i = e[h], n = i._datasets[a] = [], o = e.isDatasetVisible(a), s = e.data.datasets[a], l = pe(s, r), u = t.meta.data || [], v = e.ctx, d, y, $, T, S, B, c, _;\n    for (v.save(), d = 0, $ = u.length; d < $; ++d)\n      if (c = u[d], c[h] = [], o && c && e.getDataVisibility(d) && !c.skip)\n        for (y = 0, T = l.labels.length; y < T; ++y)\n          S = l.labels[y], B = S._key, _ = new L(S, v, c, d), _.$groups = {\n            _set: a,\n            _key: B || U\n          }, _.$context = {\n            active: !1,\n            chart: e,\n            dataIndex: d,\n            dataset: s,\n            datasetIndex: a\n          }, _.update(_.$context), c[h].push(_), n.push(_);\n    v.restore(), g(i._listeners, l.listeners, {\n      merger: function(k, C, X) {\n        C[k] = C[k] || {}, C[k][t.index] = X[k], i._listened = !0;\n      }\n    });\n  },\n  afterUpdate: function(e) {\n    e[h]._labels = w.prepare(e[h]._datasets);\n  },\n  // Draw labels on top of all dataset elements\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n  afterDatasetsDraw: function(e) {\n    w.draw(e, e[h]._labels);\n  },\n  beforeEvent: function(e, t) {\n    if (e[h]._listened) {\n      var r = t.event;\n      switch (r.type) {\n        case \"mousemove\":\n        case \"mouseout\":\n          we(e, r);\n          break;\n        case \"click\":\n          ge(e, r);\n          break;\n      }\n    }\n  },\n  afterEvent: function(e) {\n    var t = e[h], r = t._actives, a = t._actives = e.getActiveElements(), i = m.arrayDiff(r, a), n, o, s, l, u, v, d;\n    for (n = 0, o = i.length; n < o; ++n)\n      if (u = i[n], u[1])\n        for (d = u[0].element[h] || [], s = 0, l = d.length; s < l; ++s)\n          v = d[s], v.$context.active = u[1] === 1, v.update(v.$context);\n    (t._dirty || i.length) && (w.update(t._labels), e.render()), delete t._dirty;\n  }\n};\nexport {\n  Me as default\n};\n//# sourceMappingURL=chartjs-plugin-datalabels.es.js.map\n"],"names":[],"sourceRoot":""}